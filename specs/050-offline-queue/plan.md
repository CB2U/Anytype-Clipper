# Implementation Plan: Offline Queue System

## Architecture Overview

### Key Components

#### 1. QueueManager
**Responsibility:** Manage queue operations (add, get, update, delete, process)  
**Location:** `src/background/queue-manager.ts` (new file)  
**Interface:**
```typescript
interface QueueManager {
  add(item: QueueItem): Promise<void>;
  getNext(): Promise<QueueItem | null>;
  updateStatus(id: string, status: QueueStatus): Promise<void>;
  markSent(id: string): Promise<void>;
  markFailed(id: string, error: string): Promise<void>;
  delete(id: string): Promise<void>;
  getAll(): Promise<QueueItem[]>;
  getPending(): Promise<QueueItem[]>;
  clear(): Promise<void>;
  processNext(): Promise<void>;
}
```

#### 2. QueueItem
**Responsibility:** Data structure for queue items  
**Location:** `src/types/queue.d.ts` (new file)  
**Interface:**
```typescript
interface QueueItem {
  id: string; // UUID
  type: 'bookmark' | 'highlight' | 'article';
  payload: CapturePayload; // Varies by type
  status: QueueStatus;
  timestamps: {
    created: number;
    lastAttempt?: number;
    completed?: number;
  };
  retryCount: number;
  error?: string;
}

enum QueueStatus {
  Queued = 'queued',
  Sending = 'sending',
  Sent = 'sent',
  Failed = 'failed'
}
```

#### 3. StorageManager Integration
**Responsibility:** Persist queue to chrome.storage.local  
**Location:** `src/lib/storage/storage-manager.ts` (existing, modify)  
**New Methods:**
- `getQueue(): Promise<QueueItem[]>`
- `setQueue(items: QueueItem[]): Promise<void>`
- `addQueueItem(item: QueueItem): Promise<void>`
- `updateQueueItem(id: string, updates: Partial<QueueItem>): Promise<void>`
- `deleteQueueItem(id: string): Promise<void>`

### Module Boundaries

```
src/background/
├── service-worker.ts       # MODIFY: Integrate QueueManager
├── queue-manager.ts        # NEW: Queue operations
└── api-client.ts           # EXISTING: Used by QueueManager to send captures

src/lib/storage/
└── storage-manager.ts      # MODIFY: Add queue storage methods

src/types/
└── queue.d.ts              # NEW: Queue type definitions
```

### Call Flow

```
User Triggers Capture (Bookmark/Highlight/Article)
  ↓
Service Worker: Capture Handler
  ↓
Try to send to Anytype API
  ↓
API Unavailable (Network Error, 401, etc.)
  ↓
QueueManager.add(captureItem)
  ↓
StorageManager.addQueueItem(item)
  ↓
Persist to chrome.storage.local
  ↓
Return success to user (show "Queued" notification)

---

When Anytype Becomes Available (Epic 5.1 will implement auto-retry):
  ↓
QueueManager.processNext()
  ↓
Get next queued item (FIFO)
  ↓
Update status to "sending"
  ↓
Try to send to Anytype API
  ↓
Success → markSent(id)
Failure → markFailed(id, error)
  ↓
Persist status update
  ↓
Process next item (sequential)
```

### Alternatives Considered

#### Alternative 1: Store Queue in IndexedDB
**Approach:** Use IndexedDB instead of chrome.storage.local  
**Pros:** Larger storage capacity, better performance for large datasets  
**Cons:** More complex API, requires additional library, not as simple as chrome.storage  
**Decision:** Rejected. chrome.storage.local is simpler, sufficient for 1000 items, and already integrated via StorageManager.

#### Alternative 2: Parallel Processing
**Approach:** Process multiple queue items in parallel  
**Pros:** Faster queue processing  
**Cons:** May overload Anytype API, harder to manage state, violates FR6.10 (sequential processing)  
**Decision:** Rejected per PRD requirement for sequential processing.

#### Alternative 3: In-Memory Queue
**Approach:** Keep queue in memory, only persist on browser close  
**Pros:** Faster operations, simpler implementation  
**Cons:** Data loss on service worker termination, violates AC8  
**Decision:** Rejected. Queue must persist immediately to survive service worker termination.

**Chosen Approach:** chrome.storage.local with sequential processing wins because:
- Aligns with PRD requirements (FR6.1, FR6.9, FR6.10)
- Leverages existing StorageManager
- Survives browser restart and service worker termination
- Simple and testable

---

## Data Contracts

### QueueItem
```typescript
interface QueueItem {
  id: string; // UUID generated by crypto.randomUUID()
  type: 'bookmark' | 'highlight' | 'article';
  payload: CapturePayload;
  status: QueueStatus;
  timestamps: {
    created: number; // Unix timestamp (ms)
    lastAttempt?: number; // Unix timestamp (ms)
    completed?: number; // Unix timestamp (ms)
  };
  retryCount: number; // Incremented by Epic 5.1
  error?: string; // Error message if failed
}
```

### QueueStatus
```typescript
enum QueueStatus {
  Queued = 'queued',   // Waiting to be processed
  Sending = 'sending', // Currently being sent
  Sent = 'sent',       // Successfully sent
  Failed = 'failed'    // Failed after retries
}
```

### CapturePayload
```typescript
type CapturePayload = BookmarkPayload | HighlightPayload | ArticlePayload;

interface BookmarkPayload {
  url: string;
  title: string;
  tags: string[];
  notes?: string;
  metadata: PageMetadata;
}

interface HighlightPayload {
  quote: string;
  context: string;
  url: string;
  pageTitle: string;
  tags: string[];
}

interface ArticlePayload {
  url: string;
  title: string;
  content: string; // Markdown
  metadata: PageMetadata;
  tags: string[];
}
```

---

## Storage and Persistence

### chrome.storage.local Schema

```typescript
interface StorageSchema {
  // Existing fields from Epic 1.2
  apiKey?: string;
  defaultSpace?: string;
  settings: UserSettings;
  
  // NEW: Queue storage
  queue: QueueItem[]; // Array of queue items
}
```

### Storage Operations

#### Add Item
```typescript
async addQueueItem(item: QueueItem): Promise<void> {
  const queue = await this.getQueue();
  
  // FIFO eviction if queue is full
  if (queue.length >= 1000) {
    const queuedItems = queue.filter(i => i.status === 'queued');
    if (queuedItems.length > 0) {
      // Remove oldest queued item
      const oldestIndex = queue.indexOf(queuedItems[0]);
      queue.splice(oldestIndex, 1);
      console.debug('[QueueManager] Evicted oldest queued item (FIFO)');
    }
  }
  
  queue.push(item);
  await this.setQueue(queue);
}
```

#### Get Next Item (FIFO)
```typescript
async getNext(): Promise<QueueItem | null> {
  const queue = await this.getQueue();
  const queuedItems = queue.filter(i => i.status === 'queued');
  return queuedItems.length > 0 ? queuedItems[0] : null;
}
```

#### Update Item Status
```typescript
async updateStatus(id: string, status: QueueStatus): Promise<void> {
  const queue = await this.getQueue();
  const item = queue.find(i => i.id === id);
  if (item) {
    item.status = status;
    item.timestamps.lastAttempt = Date.now();
    if (status === 'sent' || status === 'failed') {
      item.timestamps.completed = Date.now();
    }
    await this.setQueue(queue);
  }
}
```

---

## External Integrations

### Anytype API Client
**Integration Point:** QueueManager uses existing API client to send captures  
**Modification:** None required. QueueManager calls existing methods:
- `createBookmark(payload)`
- `createHighlight(payload)`
- `createArticle(payload)`

### Capture Flows
**Integration Point:** Bookmark, Highlight, Article capture flows  
**Modification:** Add queue fallback when API is unavailable

**Example (Bookmark Capture):**
```typescript
async function captureBookmark(payload: BookmarkPayload): Promise<void> {
  try {
    await apiClient.createBookmark(payload);
    showNotification('Bookmark saved!');
  } catch (error) {
    if (error instanceof NetworkError || error instanceof AuthError) {
      // Queue for later
      await queueManager.add({
        id: crypto.randomUUID(),
        type: 'bookmark',
        payload,
        status: QueueStatus.Queued,
        timestamps: { created: Date.now() },
        retryCount: 0
      });
      showNotification('Bookmark queued (Anytype offline)');
    } else {
      throw error;
    }
  }
}
```

---

## UX and Operational States

### Queue States
1. **Empty:** No items in queue
2. **Queued:** Items waiting to be processed
3. **Processing:** Item currently being sent
4. **Sent:** Items successfully sent (can be cleared)
5. **Failed:** Items failed after retries (can be retried or deleted)

### User-Facing Behavior
- **Queue Add:** Show "Queued" notification when item added
- **Queue Processing:** (Epic 5.3 will add badge counter and status display)
- **Queue Success:** Show success notification when item sent
- **Queue Failure:** (Epic 5.1 will handle retry logic and error notifications)

### Error Handling
- **Storage Quota Exceeded:** Evict oldest queued items, log warning
- **Invalid Queue Item:** Log error, skip item
- **Serialization Error:** Log error, skip item
- **API Error:** Mark item as failed, log error (Epic 5.1 will retry)

---

## Testing Plan

### Unit Tests

#### Test File: `tests/unit/queue-manager.test.ts`
**Coverage:**
- Add item to queue
- Get next item (FIFO)
- Update item status
- Mark item as sent
- Mark item as failed
- Delete item
- Get all items
- Get pending items
- Clear queue
- FIFO eviction (1000 item limit)
- Handle invalid items
- Performance benchmarks (add, get, update <100ms)

**Example Test:**
```typescript
describe('QueueManager', () => {
  let queueManager: QueueManager;
  let mockStorage: MockStorageManager;

  beforeEach(() => {
    mockStorage = new MockStorageManager();
    queueManager = new QueueManager(mockStorage);
  });

  it('should add item to queue', async () => {
    const item: QueueItem = {
      id: 'test-id',
      type: 'bookmark',
      payload: { url: 'https://example.com', title: 'Test' },
      status: QueueStatus.Queued,
      timestamps: { created: Date.now() },
      retryCount: 0
    };

    await queueManager.add(item);
    const queue = await queueManager.getAll();
    expect(queue).toHaveLength(1);
    expect(queue[0].id).toBe('test-id');
  });

  it('should get next item in FIFO order', async () => {
    await queueManager.add(createItem('item1', Date.now() - 1000));
    await queueManager.add(createItem('item2', Date.now()));
    
    const next = await queueManager.getNext();
    expect(next?.id).toBe('item1');
  });

  it('should evict oldest queued item when queue is full', async () => {
    // Add 1000 items
    for (let i = 0; i < 1000; i++) {
      await queueManager.add(createItem(`item${i}`, Date.now() + i));
    }
    
    // Add one more
    await queueManager.add(createItem('item1000', Date.now() + 1000));
    
    const queue = await queueManager.getAll();
    expect(queue).toHaveLength(1000);
    expect(queue.find(i => i.id === 'item0')).toBeUndefined(); // Oldest evicted
  });
});
```

---

### Integration Tests

#### Test File: `tests/integration/queue-persistence.test.ts`
**Coverage:**
- Add items to queue, verify persistence to chrome.storage.local
- Simulate service worker termination, verify queue intact
- Process queue items sequentially
- Verify FIFO order
- Verify queue survives browser restart (manual test)

**Example Test:**
```typescript
describe('Queue Persistence', () => {
  it('should persist queue to chrome.storage.local', async () => {
    const queueManager = new QueueManager(storageManager);
    
    await queueManager.add(createBookmarkItem());
    await queueManager.add(createHighlightItem());
    
    // Read directly from storage
    const storage = await chrome.storage.local.get('queue');
    expect(storage.queue).toHaveLength(2);
  });

  it('should survive service worker termination', async () => {
    const queueManager1 = new QueueManager(storageManager);
    await queueManager1.add(createBookmarkItem());
    
    // Simulate service worker termination (create new instance)
    const queueManager2 = new QueueManager(storageManager);
    const queue = await queueManager2.getAll();
    
    expect(queue).toHaveLength(1);
  });

  it('should process queue items sequentially', async () => {
    const queueManager = new QueueManager(storageManager);
    const processOrder: string[] = [];
    
    await queueManager.add(createItem('item1'));
    await queueManager.add(createItem('item2'));
    await queueManager.add(createItem('item3'));
    
    // Mock API client to track order
    mockApiClient.createBookmark = async (payload) => {
      processOrder.push(payload.id);
    };
    
    await queueManager.processNext();
    await queueManager.processNext();
    await queueManager.processNext();
    
    expect(processOrder).toEqual(['item1', 'item2', 'item3']);
  });
});
```

---

### Manual Verification Tests

#### Manual Test 1: Queue Survives Browser Restart
**Steps:**
1. Open extension
2. Close Anytype Desktop
3. Capture 3 bookmarks (should be queued)
4. Open extension popup, verify 3 items queued (Epic 5.3 will add UI)
5. Close browser completely
6. Reopen browser
7. Open extension popup, verify 3 items still queued
8. Start Anytype Desktop
9. Verify items are processed (Epic 5.1 will add auto-retry)

**Expected Result:** Queue persists across browser restart

---

#### Manual Test 2: FIFO Eviction
**Steps:**
1. Close Anytype Desktop
2. Capture 1001 bookmarks (use script or manual)
3. Verify queue has 1000 items (oldest evicted)
4. Verify first item captured is not in queue

**Expected Result:** Oldest queued item evicted when queue reaches 1000

---

#### Manual Test 3: Sequential Processing
**Steps:**
1. Close Anytype Desktop
2. Capture 5 bookmarks
3. Start Anytype Desktop
4. Observe processing order (Epic 5.1 will add auto-retry)
5. Verify items processed in FIFO order

**Expected Result:** Items processed sequentially in FIFO order

---

## AC Verification Mapping

### AC5: Extension Queues Captures When Anytype Is Not Running
**Verification:**
- Unit tests: `queue-manager.test.ts` (add, get, update operations)
- Integration tests: `queue-persistence.test.ts` (persistence, FIFO)
- Manual test: Manual Test 1 (browser restart)
- **Evidence:** Test results + manual test screenshots

**Note:** Full AC5 verification requires Epic 5.1 (auto-retry) and Epic 5.3 (queue UI).

---

### AC8: Queue Survives Browser Restart and Service Worker Termination
**Verification:**
- Integration test: `queue-persistence.test.ts` (service worker termination)
- Manual test: Manual Test 1 (browser restart)
- **Evidence:** Test results + manual test screenshots

---

### AC-Q1: Queue Item Schema
**Verification:**
- Unit test: `queue-manager.test.ts` (serialize, deserialize, validation)
- **Evidence:** Test results

---

### AC-Q2: Queue Operations
**Verification:**
- Unit test: `queue-manager.test.ts` (all operations)
- **Evidence:** Test results

---

### AC-Q3: FIFO Eviction
**Verification:**
- Unit test: `queue-manager.test.ts` (eviction test)
- Manual test: Manual Test 2 (1001 items)
- **Evidence:** Test results + manual test screenshots

---

### AC-Q4: Sequential Processing
**Verification:**
- Integration test: `queue-persistence.test.ts` (sequential processing)
- Manual test: Manual Test 3 (observe order)
- **Evidence:** Test results + manual test screenshots

---

### AC-Q5: Queue Persistence
**Verification:**
- Integration test: `queue-persistence.test.ts` (persistence, service worker termination)
- Manual test: Manual Test 1 (browser restart)
- **Evidence:** Test results + manual test screenshots

---

## Risks and Mitigations

### Risk: Storage Quota Exceeded
**Mitigation:** FIFO eviction at 1000 items, storage quota monitoring (Epic 1.2), compression for large payloads.

### Risk: Service Worker Termination During Processing
**Mitigation:** Atomic operations for small captures, checkpoint-based recovery for large articles (Epic 10.2), reset "sending" items to "queued" on startup (Epic 5.2).

### Risk: Concurrent Queue Access
**Mitigation:** Sequential processing, test concurrent access scenarios.

### Risk: Queue Corruption
**Mitigation:** Validate queue items, handle serialization errors, provide "Clear Queue" option (Epic 5.3).

### Risk: Performance Degradation
**Mitigation:** Performance benchmarks, optimize storage queries, limit queue to 1000 items.

---

## Rollout and Migration Notes

### Rollout Strategy
- **Phase 1:** Implement QueueManager and queue storage (T1-T4)
- **Phase 2:** Integrate with capture flows (T5)
- **Phase 3:** Unit and integration tests (T6-T8)
- **Phase 4:** Manual verification (T9-T11)
- **Phase 5:** Documentation and tracking updates (T12-T14)
- **Phase 6:** Merge to main

### Migration Notes
- No data migration required (new feature)
- Existing captures unaffected (queue is optional fallback)
- Backward compatible with existing storage schema

### Feature Flag
Not required. Queue is transparent to user (no UI in this epic).

---

## Observability and Debugging

### What Can Be Logged
- Queue operations (add, get, update, delete) at debug level
- Queue size and status counts at debug level
- FIFO eviction events at debug level
- Errors during queue operations at error level
- Performance metrics (operation times) at debug level

### What Must Never Be Logged
- Full queue item payloads (privacy, verbosity)
- User content from captures (privacy)
- API keys or sensitive metadata (security)

### Debug Output Example
```
[DEBUG] QueueManager: Added item to queue (id: abc123, type: bookmark)
[DEBUG] QueueManager: Queue size: 5 (queued: 3, sending: 1, sent: 1, failed: 0)
[DEBUG] QueueManager: FIFO eviction triggered (queue size: 1000)
[DEBUG] QueueManager: Evicted oldest queued item (id: xyz789)
[DEBUG] QueueManager: Processing next item (id: abc123, type: bookmark)
[DEBUG] QueueManager: Item sent successfully (id: abc123)
[ERROR] QueueManager: Failed to add item to queue (storage quota exceeded)
```

---

**End of Implementation Plan**
